using JSON
using Printf

const DATA_DIR = joinpath(@__DIR__, "vscode-unicode-data", "out")
const OUTPUT_FILE = joinpath(@__DIR__, "lua", "data.lua")

function to_vim_unicode_regex(cp::Int)
    hex_str = @sprintf "%X" cp
    return "\\\\%u" * hex_str
end

function ambiguous_data_to_table(json_string::String)
    data = JSON.parse(json_string)
    data = JSON.parse(data)

    # 변경: 중복을 허용하지 않는 Set을 생성하여 모든 유니코드를 저장합니다.
    unique_entries = Set()

    for (key, values) in data
        for i in 1:2:length(values)
            if i + 1 <= length(values)
                cp1 = values[i]
                cp2 = values[i+1]
                entry = "    { \"$(to_vim_unicode_regex(cp1))\", \"$(to_vim_unicode_regex(cp2))\" }"
                push!(unique_entries, entry)
            else
                cp = values[i]
                entry = "    { \"$(to_vim_unicode_regex(cp))\" }"
                push!(unique_entries, entry)
            end
        end
    end

    # 변경: Set에 저장된 모든 유니크한 항목들을 배열로 변환 후 정렬하고, 쉼표로 연결합니다.
    sorted_entries = sort(collect(unique_entries))
    return "{\n" * join(sorted_entries, ",\n") * "\n}"
end

function invisible_data_to_table(json_string::String)
    data = JSON.parse(json_string)
    data = JSON.parse(data)

    # 변경: 중복을 허용하지 않는 Set을 생성합니다.
    unique_patterns = Set()

    for (key, values) in data
        for i in values
            code = to_vim_unicode_regex(i)
            push!(unique_patterns, code)
        end
    end

    # 변경: Set의 각 항목에 따옴표를 붙이고 정렬한 뒤, 쉼표로 연결합니다.
    # 
    sorted_patterns = sort(collect(unique_patterns))
    formatted_entries = ["\"$p\"" for p in sorted_patterns]
    return "{ " * join(formatted_entries, ", ") * " }"
end

function main()
    println("Generating data.lua from JSON files...")

    try
        ambiguous_data = read(joinpath(DATA_DIR, "ambiguous.json"), String)
        invisible_data = read(joinpath(DATA_DIR, "invisibleCharacters.json"), String)

        lua_content = """
        -- This file is auto-generated by a Julia script. Do not edit manually!

        local M = {}

        M.ambiguous = $(ambiguous_data_to_table(ambiguous_data))

        M.invisible = $(invisible_data_to_table(invisible_data))

        return M
        """

        mkpath(dirname(OUTPUT_FILE))

        open(OUTPUT_FILE, "w") do f
            write(f, lua_content)
        end

        println(" Successfully created $(OUTPUT_FILE)")

    catch e
        @error "An error occurred during script execution:" e [cite: 8]
    end
end

main()
